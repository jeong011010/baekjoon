
# 백준 1463 1로 만들기 문제
- dynamic programming algorithm.

* 피보나치 이후로 dp를 처음 사용해본 문제.
* 문제 조건
  1. x가 3으로 나누어 떨어지면 3으로 나눔.
  2. x가 2로 나누어 떨어지면 2로 나눔.
  3. 1을 뺌.
  * 이중 하나를 사용가능.

  * 수행시간이 짧기에, 같은 부분이 여러번 계산이 필요한 문제인 경우 DP를 사용.
  * 입력한 숫자만큼 for문 반복
    * DP 배열에 이전 DP에서 + 1한 만큼 저장(DP[i]-1 / ?)
    * 1만 빼면 이전에 한 계산만큼 하면 되기 때문. (우선 3번 조건 사용)
  * 2로 나누어 떨어지면 min함수 사용하여 DP[i/2] + 1 와 DP[i] 비교
    * 2로 나누어 떨어질 시, DP[i]에서 2로 한번 나눈 후 DP[i/2]값을 더한 만큼 저장
  * 3으로 나누어 떨어지면 min함수 사용하여 DP[i/3] + 1 와 DP[i] 비교
    * 3으로 나누어 떨어질 시, DP[i]에서 3으로 한번 나눈 후 DP[i/3]값을 더한 만큼 저장
 
```C
#include<iostream>
using namespace std;

int DP[1000001];

int main() {
	int x;
	cin >> x;
	for (int i = 2; i <= x; ++i) {
		DP[i] = DP[i - 1] + 1;
		if (i % 2 == 0)DP[i] = min(DP[i], DP[i / 2] + 1);
		if (i % 3 == 0)DP[i] = min(DP[i], DP[i / 3] + 1);
	}
	cout << DP[x] << '\n';
	return 0;
}
```

Dynamic programming을 처음 적용해본 문제.

알고리즘을 공부만 하기 보다는, 적절하게 응용을 잘 하는것이 훨씬 중요한듯.
DP알고리즘은 알고리즘 사용과 동시에 약간의 아이디어도 필요하다고 생각이 듬. 더 많은 DP를 풀어봐야 할 필요가 있다고 느낌. 
