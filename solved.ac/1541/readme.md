
# 백준 1541 잃어버린 괄호
- greedy algorithm과 문자열을 이용하여 풀어낸 문제

## 풀이
- 처음에는 stack을 이용하여 -가 나올 때 '("처럼 push하고 +나 문장이 끝났을 떄 pop하는 식으로 설계하였음.
- 하지만 배열을 이용하여 stack을 쉽게 구현할 수 있었음.

- 이 문제의 특이점은 + 부분을 먼저 다 계산해 준 뒤, 남은 - 부분을 계산하면 된다는 점.
- string을 이용하여 문자열을 받은 뒤, for문을 이용하여 숫자와 부호를 구분.
- 숫자인 경우 x10, i++을 이용하여 자릿수를 만들어줌.
- +가 나온 경우 flag를 변화시켜주어 이전 숫자에 더하고 j--를 시켜 스택의 pop처럼 구현함.
- 이후 배열에 남은 수를 arr[0]을 시작으로 전부 뺌.

```C
string s;
int arr[51];

int main() {
	int j = 0, flag=0;
	cin >> s;
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '+') flag = 1;
		else if (s[i] == '-') flag = 0;
		else {
			arr[j] += s[i]-48;
			while (s[i + 1] != '+' && s[i + 1] != '-' && i<s.size()-1) {
				arr[j] *= 10;
				i++;
				arr[j] += s[i] - 48;
			}
			j++;
			if (flag == 1) {
				j--;
				arr[j - 1] += arr[j];
				arr[j] = 0;
				flag = 0;
			}
		}
	}
	j--;
	int sum = arr[0];
	for (int i = 1; i <= j; i++) {
		sum -= arr[i];
	}
	cout << sum;
}
```

- 문제는 쉬웠지만, stack을 써야한다는 강박관념에 사로잡혀 조금 해매었던 문제.

##
- 솔직히 그리디 알고리즘 분류로 볼 수 있긴하지만, 딱히 그리디 알고리즘을 사용하고 있다는 생각을 못함.
- 근데 + 우선 계산하고 나머지를 더한걸로 봤을 때 그리디 알고리즘에 속한다고 볼 수 있긴 한듯.
